<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · Tethers.jl</title><meta name="title" content="Readme · Tethers.jl"/><meta property="og:title" content="Readme · Tethers.jl"/><meta property="twitter:title" content="Readme · Tethers.jl"/><meta name="description" content="Documentation for Tethers.jl."/><meta property="og:description" content="Documentation for Tethers.jl."/><meta property="twitter:description" content="Documentation for Tethers.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Tethers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Readme</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Basic-example"><span>Basic example</span></a></li><li><a class="tocitem" href="#Python-version-as-comparison"><span>Python version as comparison</span></a></li><li><a class="tocitem" href="#More-examples"><span>More examples</span></a></li><li><a class="tocitem" href="#Comparism"><span>Comparism</span></a></li><li><a class="tocitem" href="#Using-Python-together-with-Julia"><span>Using Python together with Julia</span></a></li></ul></li><li><a class="tocitem" href="python/">Python and Julia</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Readme</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Readme</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/Tethers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/Tethers.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tethers.jl"><a class="docs-heading-anchor" href="#Tethers.jl">Tethers.jl</a><a id="Tethers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Tethers.jl" title="Permalink"></a></h1><p>A series of examples, from a simple falling mass towards a tether model, consisting of point masses connected by spring damper elements with support of reel-out and reel-in and aerodynamic drag attached.</p><p>– WORK IN PROGRESS –</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><ol><li>make sure you are running a <code>bash</code> terminal (shell) and you have at least 16GB RAM (MAC, Linux and Windows supported).   On Windows, you can use <a href="https://gitforwindows.org/">git for windows</a> which provides git AND a bash shell, but for using Julia from a <code>bash</code> terminal you must also install either  <a href="docs/images/vscode/">Installation and usage of VSCode</a> or <a href="https://learn.microsoft.com/en-us/windows/terminal/install">Windows Terminal</a>. <code>Windows Terminal</code> is the simple and clean solution, <code>VSCode</code> the comfortable, fancy solution.</li><li>install Julia 1.10 using <code>juliaup</code>, see <a href="https://github.com/JuliaLang/juliaup">https://github.com/JuliaLang/juliaup</a>. If <code>juliaup</code> is already installed, the following commands will do:</li></ol><pre><code class="nohighlight hljs">juliaup add 1.10
juliaup default 1.10 </code></pre><p>Check out from git:</p><pre><code class="language-bash hljs">cd repos # any folder of your choice, but without spaces in the folder name
git clone https://github.com/ufechner7/Tethers.jl</code></pre><p>Build the system image:</p><pre><code class="language-bash hljs">cd repos/Tethers.jl
cd bin
./create_sys_image</code></pre><h2 id="Basic-example"><a class="docs-heading-anchor" href="#Basic-example">Basic example</a><a id="Basic-example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-example" title="Permalink"></a></h2><p>Use the provided script to start Julia from the <code>Tethers.jl</code> folder:</p><pre><code class="language-bash hljs">cd repos/Tethers.jl
./bin/run_julia</code></pre><p>From the Julia prompt, run the simulation:</p><pre><code class="language-julia hljs">include(&quot;src/Tether_01.jl&quot;)</code></pre><p>You should see a plot similar to:</p><p><img src="docs/images/FallingMass.png" alt="Falling mass"/></p><p>This example shows a mass that is thrown upwards, slows down and then falls.</p><p><strong>Julia code:</strong> <a href="src/Tether_01.jl">Tether_01.jl</a></p><p>These differential equations define the model:</p><pre><code class="language-Julia hljs">D = Differential(t)

eqs = vcat(D.(pos) ~ vel,
           D.(vel) ~ acc,
           acc    .~ G_EARTH)</code></pre><p>The term <code>D.(pos)</code> means &quot;Apply the differential D(t) to all elements of the vector <code>pos</code>&quot;. The second term defines that the differential of the velocity vector must be equal to the  acceleration. For equality in symbolic equations the character <code>~</code> has to be used, because the character <code>=</code> has the meaning &quot;assign a value to a variable&quot; which is not what we are doing here. The third equation means that all elements of the acceleration vector must be equal to the elements of the gravity vector. We end up with an array of <code>3x3</code>` equations.</p><p>The next lines are:</p><pre><code class="language-julia hljs">@named sys = ODESystem(eqs, t)
simple_sys = structural_simplify(sys)</code></pre><p>This means, we create a named ordinary equation system, depending on <code>t</code>. Then we simplify the system symbolically (order reduction). If you type <code>sys</code> in the Julia REPL (command line) you can see that the original system had 9 equations, the second line above created a system with ony six equations. This step helps to speed up the simulation and often also removes algebraic loops which makes the ODE a lot simple to solve numerically later on.</p><h2 id="Python-version-as-comparison"><a class="docs-heading-anchor" href="#Python-version-as-comparison">Python version as comparison</a><a id="Python-version-as-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Python-version-as-comparison" title="Permalink"></a></h2><p>From the Julia prompt execute:</p><pre><code class="nohighlight hljs">include(&quot;src/RunTether.jl&quot;)</code></pre><p>This will install Python and Matplotlib and Assimulo and execute the script <code>Tether_01.py</code>.</p><p><strong>Python code:</strong> <a href="src/Tether_01.py">Tether_01.py</a></p><p>If you compare the Python and the Julia script you can see that:</p><ul><li>the Julia script is shorter and easier to read</li><li>Julia is about 16 times faster when running the simulation</li></ul><h2 id="More-examples"><a class="docs-heading-anchor" href="#More-examples">More examples</a><a id="More-examples-1"></a><a class="docs-heading-anchor-permalink" href="#More-examples" title="Permalink"></a></h2><h3 id="Mass,-attached-to-a-spring-damper-element"><a class="docs-heading-anchor" href="#Mass,-attached-to-a-spring-damper-element">Mass, attached to a spring damper element</a><a id="Mass,-attached-to-a-spring-damper-element-1"></a><a class="docs-heading-anchor-permalink" href="#Mass,-attached-to-a-spring-damper-element" title="Permalink"></a></h3><p>From the Julia prompt, run the simulation:</p><pre><code class="language-julia hljs">include(&quot;src/Tether_02.jl&quot;)</code></pre><p><img src="docs/images/SpringDamper.png" alt="Spring damper"/></p><p>Mass, attached to a spring damper element. One end of the spring at the origin, the second end attached to the mass. Mass initially below the origin, spring un-stretched. Z-axis pointing upwards.</p><p><strong>Julia code:</strong> <a href="src/Tether_02.jl">Tether_02.jl</a></p><h3 id="Mass,-attached-to-a-non-linear-spring-damper-element"><a class="docs-heading-anchor" href="#Mass,-attached-to-a-non-linear-spring-damper-element">Mass, attached to a non-linear spring damper element</a><a id="Mass,-attached-to-a-non-linear-spring-damper-element-1"></a><a class="docs-heading-anchor-permalink" href="#Mass,-attached-to-a-non-linear-spring-damper-element" title="Permalink"></a></h3><pre><code class="language-julia hljs">include(&quot;src/Tether_03.jl&quot;)</code></pre><p><img src="docs/images/Nonlinear.png" alt="Non-linear Spring damper"/></p><p>Mass, attached to a spring damper element. One end of the spring at the origin, the second end attached to the mass. Mass initially below the origin, spring un-stretched. Z-axis pointing upwards. </p><p>Initial velocity <span>$4 m/s$</span> upwards. The compression stiffness is zero. The grey line shows that the stiffness is zero at the beginning, and has the nominal value at the end. <strong>Example:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_03.jl">Tether_03.jl</a>.</p><p>Thanks to the package <a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit.jl</a> the system description is very compact and readable:</p><pre><code class="language-Julia hljs">D = Differential(t)
eqs = vcat(D.(pos)      ~ vel,
           D.(vel)      ~ acc,
           norm1        ~ norm(pos),
           unit_vector  ~ -pos/norm1,         # direction from point mass to origin
           spring_vel   ~ -unit_vector ⋅ vel,
           c_spring     ~ c_spring0 * (norm1 &gt; abs(l0)),
           spring_force ~ (c_spring * (norm1 - abs(l0)) + damping * spring_vel) * unit_vector,
           acc          ~ G_EARTH + spring_force/mass)</code></pre><p>The same as Python version: <strong>Python code:</strong> <a href="src/Tether_03.py">Tether_03.py</a>. </p><h4 id="Using-a-callback"><a class="docs-heading-anchor" href="#Using-a-callback">Using a callback</a><a id="Using-a-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-callback" title="Permalink"></a></h4><p>By using a callback to detect exactly when the transition from a stiff tether segment to a loose tether segment happens we can increase the accuracy of the simulation. <strong>Julia code:</strong> <a href="src/Tether_03b.jl">Tether_03b.jl</a>.</p><p>We only have to add the following lines of code:</p><pre><code class="language-julia hljs">function condition(u, t, integrator) # Event when condition(u,t,integrator) == 0
    norm(u[1:3]) - abs(L0)
end
`function affect!(integrator)
    println(integrator.t)            # Not needed, just to show that the callback works
end
cb = ContinuousCallback(condition, affect!)</code></pre><p>and add the parameter <code>callback = cb</code> to the line that calls the solver:</p><pre><code class="language-julia hljs">sol = solve(prob, Rodas5(), dt=dt, abstol=tol, reltol=tol, saveat=ts, callback = cb)</code></pre><h4 id="Using-a-callback-with-Python"><a class="docs-heading-anchor" href="#Using-a-callback-with-Python">Using a callback with Python</a><a id="Using-a-callback-with-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-callback-with-Python" title="Permalink"></a></h4><p>In Python you would have to add the following attribute:</p><pre><code class="language-Python hljs">    sw0 = [vel_1[2] &gt; 0] # array of booleans; true means the tether segment is loose (l &lt; l_0)</code></pre><p>and the following methods:</p><pre><code class="language-Python hljs">    def state_events(self, t, y, yd, sw):
        &quot;&quot;&quot;
        This is our function that keeps track of our events. When the sign
        of any of the events has changed, we have an event.
        &quot;&quot;&quot;
        # calculate the norm of the vector from mass1 to mass0 minus the initial segment length
        event_0 = np.linalg.norm(y[3:6]) - L_0
        return np.array([event_0])
    
    def handle_event(self, solver, event_info):
        &quot;&quot;&quot;
        Event handling. This functions is called when Assimulo finds an event as
        specified by the event functions.
        &quot;&quot;&quot;
        state_info = event_info[0] # We are only interested in state events
        if state_info[0] != 0:     # Check if the first event function has been triggered
            if solver.sw[0]:       # If the switch is True the pendulum bounces
                print(solver.t)</code></pre><p><strong>Example:</strong> <a href="src/Tether_03b.py">Tether_03b.py</a>.   As you can see, logging of calculated variables is not possible with Assimulo (easy with ModelingToolkit in Julia). You need to re-calculate them after the simulation.</p><h4 id="Multi-segment-tether"><a class="docs-heading-anchor" href="#Multi-segment-tether">Multi-segment tether</a><a id="Multi-segment-tether-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-segment-tether" title="Permalink"></a></h4><p>Using 2D arrays of variables allows to simulate a multi-segment tether:</p><pre><code class="language-julia hljs">@variables pos(t)[1:3, 1:segments+1]  = POS0
@variables vel(t)[1:3, 1:segments+1]  = VEL0
@variables acc(t)[1:3, 1:segments+1]  = ACC0</code></pre><p>In this case it is important to calculate the initial conditions of each particle such that they are physically feasible:</p><pre><code class="language-julia hljs">G_EARTH     = Float64[0.0, 0.0, -9.81]          # gravitational acceleration     [m/s²]
L0::Float64 = 10.0                              # initial segment length            [m]
V0::Float64 = 4                                 # initial velocity of lowest mass [m/s]
segments::Int64 = 2                             # number of tether segments         [-]
POS0 = zeros(3, segments+1)
VEL0 = zeros(3, segments+1)
ACC0 = zeros(3, segments+1)
SEGMENTS0 = zeros(3, segments) 
UNIT_VECTORS0 = zeros(3, segments)
for i in 1:segments+1
    POS0[:, i] .= [0.0, 0, -(i-1)*L0]
    VEL0[:, i] .= [0.0, 0, (i-1)*V0/segments]
end
for i in 2:segments+1
    ACC0[:, i] .= G_EARTH
end
for i in 1:segments
    UNIT_VECTORS0[:, i] .= [0, 0, 1.0]
    SEGMENTS0[:, i] .= POS0[:, i+1] - POS0[:, i]
end</code></pre><p>The first example of such a model is the script <a href="src/Tether_04.jl">Tether_04.jl</a> which is derived from the last example.</p><p>In the script <a href="src/Tether_05.jl">Tether_05.jl</a> the spring force is distributed correctly on the two masses attached to the spring as shown here:</p><pre><code class="language-julia hljs">if i == segments
    eqs2 = vcat(eqs2, total_force[:, i] ~ spring_force[:, i])
else
    eqs2 = vcat(eqs2, total_force[:, i] ~ spring_force[:, i]- spring_force[:, i+1])
end</code></pre><p>We loop backwards over the particles, starting with the last particle, because on the last particle only one force is acting. On particle <span>$n-1$</span> two spring forces are acting in the opposite direction.</p><p>Finally in this example we plot the result dynamically as 2D video. Screenshot:</p><p><img src="docs/images/Tether2d.png" alt="Tether 2D"/></p><h4 id="Benchmarking"><a class="docs-heading-anchor" href="#Benchmarking">Benchmarking</a><a id="Benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking" title="Permalink"></a></h4><p>Using a callback slows the simulation down, but not much. Try it out:</p><pre><code class="language-julia hljs">include(&quot;src/Tether_03c.jl&quot;)</code></pre><p>Output on a fast PC:</p><pre><code class="nohighlight hljs">Solving the system without callback...
  0.000606 seconds (8.06 k allocations: 257.672 KiB)
Press any key...

Solving the system with callback...
  0.000741 seconds (9.93 k allocations: 365.812 KiB)
If you zoom in to the points in time where pos_z crosses -10m
you should see a difference...</code></pre><p>In this example the gain of accuracy is very small, but that can be different in other simulations. For benchmarking we call solve twice: The first call ensures that the code is compiled, the second call measures the execution time of the code.</p><p><strong>Python</strong> The script, which executes the Python code with callbacks:</p><pre><code class="nohighlight hljs">include(&quot;src/RunTether_03b.jl&quot;)</code></pre><p>reports 31 ms for solving the problem (without printing). Without callbacks:</p><pre><code class="nohighlight hljs">include(&quot;src/RunTether_03.jl&quot;)</code></pre><p>still 20 ms are needed.</p><h2 id="Comparism"><a class="docs-heading-anchor" href="#Comparism">Comparism</a><a id="Comparism-1"></a><a class="docs-heading-anchor-permalink" href="#Comparism" title="Permalink"></a></h2><p>Execution time for a simulation of 10s duration with logging the state every 20ms. | Testcase                    | Lines of code (LOC) Julia | LOC Python  | Time Julia [ms] | Time Python [ms] | |:––––––––––––––|:–––––––––-:|:–-:|:-:|:–-:| |Falling mass                 |     42              | 56  | 0.17  | 2.6  | |Non-linear Spring damper     |     61              | 83  | 0.61  | 20  | |dito with callbacks          |     68              | 103 | 0.74 | 31  | |swinging tether, 5 segments  |    117              | 190    | 2.90     |     |</p><p><strong>Tradeoff Julia vs Python:</strong> In Julia the code is compiled before it is executed, that can cause about 1 to 10 seconds delay when running a simulation the first time, but speeds up the execution a lot afterwards. In addition Julia can run fully multithreaded, Python cannot really use threads because of the global interpreter lock. See also: <a href="https://ufechner7.github.io/2022/08/13/why-julia.html">Why Julia?</a></p><h2 id="Using-Python-together-with-Julia"><a class="docs-heading-anchor" href="#Using-Python-together-with-Julia">Using Python together with Julia</a><a id="Using-Python-together-with-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Python-together-with-Julia" title="Permalink"></a></h2><p>Python and Julia play very well together. You could see in the examples above that I am using Matplotlib for plotting, both in Python and in Julia. Julia has a build-in package manager. You can use it install and remove Julia packages, but also to install or remove Python packages. That works like this:</p><p><strong>Using Python packages from Julia</strong> There are three options:</p><p><strong>Option one:</strong> Use wrapper libraries which exist for a few, very popular Python packages, e.g. <a href="https://github.com/JuliaPy/PyPlot.jl">PyPlot.jl</a> for Matplotlib or <a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a> for SymPy. You can install them like any other Julia package, e.g.</p><pre><code class="nohighlight hljs">]     # enter package manager mode
add SymPy
&lt;DEL&gt; # leave the package manager</code></pre><p>and on the Julia prompt:</p><pre><code class="nohighlight hljs">using SymPy</code></pre><p><strong>Option two:</strong></p><p>Use PyCall to use Python packages for Julia. This works for all Python packages, but  is a little bit less comfortable than option one. Example:</p><pre><code class="nohighlight hljs">using PyCall
np = pyimport(&quot;numpy&quot;)</code></pre><p>Now you can use NumPy from Julia:</p><pre><code class="language-julia hljs">julia&gt; np.zeros(3)
3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>If the package is not yet installed, you can use the notation:</p><pre><code class="nohighlight hljs">as = pyimport_conda(&quot;assimulo&quot;, &quot;assimulo&quot;)</code></pre><p>If the command <code>using PyCall</code> should fail, you can execute:</p><pre><code class="nohighlight hljs">cd bin
./build_pycall</code></pre><p>to re-build it.</p><p><strong>Option three:</strong> Using the package <a href="https://github.com/JuliaPy/PythonCall.jl">PythonCall</a>. You cannot use it together with <code>PyCall</code>, it is the newer successor of <code>PyCall</code>, and it is symmetric, you can use it to call Julia from Python or Python from Julia.</p><p>We need to create a new project to try it out:</p><pre><code class="nohighlight hljs">cd repos # or any other folder that you use for your projects
mkdir PythonDemo
cd PythonDemo
julia --project=&quot;.&quot; # this creates a new, empty project</code></pre><p>Then enter at the Julia prompt:</p><pre><code class="nohighlight hljs">]               # enter the package manger mode
add PythonCall
&lt;BACK&gt;          # leave the package manager mode</code></pre><p>Example for using Python from Julia:</p><pre><code class="language-julia hljs">re = pyimport(&quot;re&quot;)   # import the re module
words = re.findall(&quot;[a-zA-Z]+&quot;, &quot;PythonCall.jl is very useful!&quot;)</code></pre><p>Output:</p><pre><code class="nohighlight hljs">Python: [&#39;PythonCall&#39;, &#39;jl&#39;, &#39;is&#39;, &#39;very&#39;, &#39;useful&#39;]</code></pre><p>Type:</p><pre><code class="language-julia hljs">sentence = Py(&quot; &quot;).join(words)</code></pre><p>Output:</p><pre><code class="nohighlight hljs">Python: &#39;PythonCall jl is very useful&#39;</code></pre><p>And finally convert this Python object to a Julia string:</p><pre><code class="language-julia hljs">pyconvert(String, sentence)  # convert the Python string to a Julia string</code></pre><p>For adding Python packages that you want to use with PythonCall use CondaPkg as explained in the next section.</p><p><strong>Sometimes needed:</strong> Install CondaPkg</p><pre><code class="nohighlight hljs">] # by pressing the closing square bracket you enter the package manager mode of Julia
add CondaPkg # add the Python package manger
</code></pre><p>Now press the \&lt;DEL\&gt; key to leave the package manager. In the Julia REPL, type:</p><pre><code class="nohighlight hljs">using CondaPkg
]                 # enter the package manager mode
help              # will show you all available commands; try for example
conda add ipython # this will add ipython</code></pre><p>Press \&lt;DEL\&gt; to leave the package manager mode. In the Julia REPL, type:</p><pre><code class="nohighlight hljs">CondaPkg.withenv() do
    run(`ipython`)
end</code></pre><p>You should now get an interactive Python prompt and can program in Python.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="python/">Python and Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 13 December 2023 14:17">Wednesday 13 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

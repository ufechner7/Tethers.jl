var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#Python","page":"References","title":"Python","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Assimulo offers 14 solvers with good documentation for explicit and implicit problems.","category":"page"},{"location":"references/#Julia","page":"References","title":"Julia","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"DifferentialEquations.jl offers a unified interface to about 300 different solvers from about a dozen different categories for a large range of problems. It wraps many existing open-source and commercial solvers, that have been implemented in C++ or Fortran and adds a growing number of native Julia solvers, many of them state-of-the-art.\nModelingToolkit.jl is an acausal modeling framework for automatically parallelized scientific machine learning (SciML) in Julia. A computer algebra system for integrated symbolics for physics-informed machine learning and automated transformations of differential equations. \nKiteModels.jl implements kite models, connected to a tether for airborne wind energy applications. It uses the same algorithms as this tutorial, but it is not (yet) using ModelingToolkit. \nWorking with Julia projects A must-read before creating your first project.","category":"page"},{"location":"references/#Scientific-papers","page":"References","title":"Scientific papers","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Uwe Fechner, Rolf van der Vlugt, Edwin Schreuder, Roland Schmehl. (2015). Dynamic Model of a Pumping Kite Power System  describes the tether model used in this tutorial, but also a model of a complete kite power system with experimental validation. Renewable Energy. Preprint.\nYingbo Ma, Shashi Gowda, Ranjan Anantharaman, Chris Laughman, Viral Shah, and Chris Rackauckas. (2021). ModelingToolkit: A Composable Graph Transformation System For Equation-Based Modeling.\nRackauckas, Christopher and Nie, Qing (2017). DifferentialEquations.jl–a performant and feature-rich ecosystem for solving differential equations in Julia} Journal of Open Research Software.\nD.F. Duda1, H. Fuest, T. Islam, T. Ostermann, D. Moormann1. (2022). Hybrid modeling approach for the tether of an airborne wind energy system CEAS Aeronautical Journal.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Math","page":"Theory","title":"Math","text":"","category":"section"},{"location":"theory/#Inputs-and-outputs","page":"Theory","title":"Inputs and outputs","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"A general tether model should be able to simulate a tether that connects two arbitrary points in space. The first tutorial examples assume one (fixed) point to be at the coordinate [0,0,0].","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We assume that one end of the tether is either fixed or attached to a winch, and the other end is fixed or attached to a load that applies a force on the tether.","category":"page"},{"location":"theory/#Inputs","page":"Theory","title":"Inputs","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Either or\np1: [x1,y1,z1] vector [m] and vel1: speed vector of point one [m/s]\nforce1: vector of force applied to point one\nEither or\np2: [x2,y2,z2] vector [m] and vel2: speed vector of point two [m/s]\nforce2: [fx2, fy2, fz2] vector of the force applied to point two [N]\nv_ro: reel-out speed at point one, scalar [m/s]\nv_wind: vector of the wind speed at reference height [m/s]","category":"page"},{"location":"theory/#Outputs","page":"Theory","title":"Outputs","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"If fix_p1:\nforce1: [fx1, fy1, fz1] force vector, felt at point one [N]\nif fix_p2:\nforce2: [fx1, fy1, fz1] force vector, felt at point one [N]\npos: vector of the position vectors of the tether particles [m]\nvel: vector of the velocity vectors of the tether particles [m/s]\nforces: vector of the scalar forces per tether segment [N]","category":"page"},{"location":"theory/#Configuration","page":"Theory","title":"Configuration","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"segments: number of tether segments [-]\nd_tether: tether diameter [mm]\nrho_tether: tether density [kg/m³]\nc_spring: unit spring constant [N]\ndamping: unit damping constant [Ns]\nl0: initial unstretched tether length [m]\nv_ro0: initial reel-out speed [m/s]\np1_0: initial position of point one [m]\np2_0: initial position of point two [m]\nvel1_0: initial speed vector of point one [m/s]\nvel2_0: initial speed vector of point two [m/s]\nrho: density of the fluid at position zero and 15 °C (water, air) [kg/m³]\nh_ref: reference height for the wind speed [m]\nalpha: exponent of the wind profile law [-]\nz0: surface roughness [m]\nprofile_law: integer, 1=EXP, 2=LOG, 3=EXPLOG, 4=FASTEXP, 5=FASTLOG, 6=FAST_EXPLOG  ","category":"page"},{"location":"theory/#Model-export-as-functional-mockup-unit","page":"Theory","title":"Model export as functional mockup unit","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Functional mockup units (FMUs) are a standard to exchange models between different simulation environments, heavily used by the car and the aerospace industries.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Simulink, Python, Modelica etc can import FMU models. They are distributed as a zip file that contains a shared library and an XML description.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A good and detailed introduction can be found here.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For the export of Julia models as FMU the package FMIExport can be used. For importing FMU models in Python the software PyFMI can be used. FMU import with Simulink is documented here.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Because not everybody is using Julia as main development and simulation environment we plan to provide a tether model as FMU, but this will not be possible before this issue is resolved.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Nomenclature:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"FMU: Functional mockup unit\nFMI: Functional mockup interface\nFMI for model exchange: A model without a solver\nFMI for co-simulation: A model that includes its own solver","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A sequence of examples, from a simple mass attached to a spring-damper element to a full segmented tether model with real-out and aerodynamic drag attached.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Name Description Learning objective\nTether_01 Mass, thrown upwards, then falling Learn how to define a model, simulate it and plot the results\nTether_02 Mass, attached to a spring-damper Learn how to model a spring in 3D\nTether_03 Mass, with non-linear spring-damper Learn how to model  DAE systems with discontinuities\nTether_04 Multi-segment tether Learn how to use arrays of equations\nTether_05 Segmented tether with correct force distribution Learn how to distribute the spring force over two masses\nTether_06 Multi-segment tether reeling out Learn to model a tether with changing unstretched length\nTether_07 Segmented tether with aerodynamic drag Learn how to model tether drag\nTether_08 Tether with arbitrary endpoints Learn how to use a steady state solver","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Nomenclature:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ODE: Ordinary differential equations\nDAE: Differential algebraic equations","category":"page"},{"location":"examples/#Mass,-thrown-upwards,-then-falling","page":"Examples","title":"Mass, thrown upwards, then falling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Use the provided script to start Julia from the Tethers.jl folder:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cd repos/Tethers.jl\n./bin/run_julia","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"From the Julia prompt, run the simulation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"src/Tether_01.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You should see a plot similar to:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Falling mass)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows a mass that is thrown upwards, slows down and then falls.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Julia code: Tether_01.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These differential equations define the model:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"D = Differential(t)\n\neqs = vcat(D.(pos) ~ vel,\n           D.(vel) ~ acc,\n           acc    .~ G_EARTH)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The term D.(pos) means \"Apply the differential D(t) to all elements of the vector pos\". The second term defines that the differential of the velocity vector must be equal to the  acceleration. For equality in symbolic equations the character ~ has to be used, because the character = has the meaning \"assign a value to a variable\" which is not what we are doing here. The third equation means that all elements of the acceleration vector must be equal to the elements of the gravity vector. We end up with an array of 3x3` equations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The next lines are:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"@named sys = ODESystem(eqs, t)\nsimple_sys = structural_simplify(sys)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This means we create a named ordinary equation system, depending on t. Then we simplify the system symbolically (order reduction). If you type sys in the Julia REPL (command line) you can see that the original system had 9 equations, the second line above created a system with only six equations. This step helps to speed up the simulation and often also removes algebraic loops which makes the ODE a lot simpler to solve numerically later on.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now the parameters of the integrator are defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"duration = 10.0\ndt = 0.02\ntol = 1e-6\nts    = 0:dt:duration","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The time step dt is the interval in which the solution shall be stored, NOT the time step of the integrator. The integrator uses a variable time step which can be much smaller or much larger as determined by the required tolerance, in this example set to tol=10^-6. The variable ts is a range object defining the sampling times for the result.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the next lines, we define the ODE problem and finally, we solve it using the Rodas5 solver with the given parameters. The second parameter defines the initial conditions. We use nothing here because we defined the initial conditions already in the model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"prob = ODEProblem(simple_sys, nothing, (0.0, duration))\n@time sol = solve(prob, Rodas5(), dt=dt, abstol=tol, reltol=tol, saveat=ts)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The macro @time measures the compilation and execution time of calling the function solve(). The function is compiled only when called the first time. ","category":"page"},{"location":"examples/#Python-version-as-comparison","page":"Examples","title":"Python version as comparison","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"From the Julia prompt execute:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"src/RunTether.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This will install Python, Matplotlib and Assimulo and execute the script Tether_01.py.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Python code: Tether_01.py","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you compare the Python and the Julia scripts you can see that:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"the Julia script is shorter and easier to read\nJulia is about 16 times faster when running the simulation","category":"page"},{"location":"examples/#Mass,-attached-to-a-spring-damper","page":"Examples","title":"Mass, attached to a spring-damper","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"From the Julia prompt, run the simulation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"src/Tether_02.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Spring damper)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Mass, attached to a spring-damper element. One end of the spring is attached at the origin, the second end is attached to the mass. Mass initially below the origin, spring un-stretched. Z-axis pointing upwards.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"After running it, type sys and simple_sys in the REPL to see the representation of the system and the simplified system. You can see that the original system has 17 equations, which have been automatically simplified to 6 equations in simple_sys.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Julia code: Tether_02.jl","category":"page"},{"location":"examples/#Mass,-with-non-linear-spring-damper","page":"Examples","title":"Mass, with non-linear spring damper","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"src/Tether_03.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Non-linear Spring damper)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Mass, attached to a non-linear spring-damper element. One end of the spring is attached at the origin, and the second end is attached to the mass. Mass initially below the origin, spring un-stretched. Z-axis pointing upwards. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Initial velocity 4 ms upwards. The compression stiffness is zero. The grey line shows that the stiffness is zero at the beginning, and has the nominal value at the end. Example: Tether_03.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Thanks to the package ModelingToolkit.jl the system description is very compact and readable:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"eqs = vcat(D.(pos)      ~ vel,\n           D.(vel)      ~ acc,\n           norm1        ~ norm(pos),\n           unit_vector  ~ -pos/norm1,         # direction from point mass to origin\n           spring_vel   ~ -unit_vector ⋅ vel,\n           c_spring     ~ c_spring0 * (norm1 > abs(l0)),\n           spring_force ~ (c_spring * (norm1 - abs(l0)) + damping * spring_vel) * unit_vector,\n           acc          ~ G_EARTH + spring_force/mass)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The same in Python: Python code: Tether_03.py. ","category":"page"},{"location":"examples/#Using-a-callback","page":"Examples","title":"Using a callback","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"By using a callback to detect exactly when the transition from a stiff tether segment to a loose tether segment happens we can increase the accuracy of the simulation. Julia code: Tether_03b.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We only have to add the following lines of code:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function condition(u, t, integrator) # Event when condition(u,t,integrator) == 0\n    norm(u[1:3]) - abs(L0)\nend\nfunction affect!(integrator)\n    println(integrator.t)            # Not needed, just to show that the callback works\nend\ncb = ContinuousCallback(condition, affect!)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and add the parameter callback = cb to the line that calls the solver:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sol = solve(prob, Rodas5(), dt=dt, abstol=tol, reltol=tol, saveat=ts, callback = cb)","category":"page"},{"location":"examples/#Using-a-callback-with-Python","page":"Examples","title":"Using a callback with Python","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In Python you would have to add the following attribute:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    sw0 = [vel_1[2] > 0] # array of booleans; true means the tether segment is loose (l < l_0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and the following methods:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    def state_events(self, t, y, yd, sw):\n        \"\"\"\n        This is our function that keeps track of our events. When the sign\n        of any of the events has changed, we have an event.\n        \"\"\"\n        # calculate the norm of the vector from mass1 to mass0 minus the initial segment length\n        event_0 = np.linalg.norm(y[3:6]) - L_0\n        return np.array([event_0])\n    \n    def handle_event(self, solver, event_info):\n        \"\"\"\n        Event handling. This functions is called when Assimulo finds an event as\n        specified by the event functions.\n        \"\"\"\n        state_info = event_info[0] # We are only interested in state events\n        if state_info[0] != 0:     # Check if the first event function has been triggered\n            if solver.sw[0]:       # If the switch is True the pendulum bounces\n                print(solver.t)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Example: Tether_03b.py.   As you can see, logging of calculated variables is not possible with Assimulo (easy with ModelingToolkit in Julia). You need to re-calculate them after the simulation.","category":"page"},{"location":"examples/#Benchmarking-non-linear-simulation","page":"Examples","title":"Benchmarking non-linear simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using a callback slows the simulation down, but not much. Try it out:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"src/Tether_03c.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Output on a fast PC:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Solving the system without callback...\n  0.000606 seconds (8.06 k allocations: 257.672 KiB)\nPress any key...\n\nSolving the system with callback...\n  0.000741 seconds (9.93 k allocations: 365.812 KiB)\nIf you zoom in to the points in time where pos_z crosses -10m\nyou should see a difference...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, the gain of accuracy is very small, but that can be different in other simulations. For benchmarking we call solve twice: The first call ensures that the code is compiled, and the second call measures the execution time of the code.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Python The script, which executes the Python code with callbacks:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"src/RunTether_03b.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"reports 31 ms for solving the problem (without printing). Without callbacks:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"include(\"src/RunTether_03.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"still, 20 ms are needed.","category":"page"},{"location":"examples/#Multi-segment-tether","page":"Examples","title":"Multi-segment tether","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using 2D arrays of variables allows to simulate a multi-segment tether:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"@variables pos(t)[1:3, 1:segments+1]  = POS0\n@variables vel(t)[1:3, 1:segments+1]  = VEL0\n@variables acc(t)[1:3, 1:segments+1]  = ACC0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this case, it is important to calculate the initial conditions of each particle such that they are physically feasible:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"G_EARTH::Vector{Float64} = [0.0, 0.0, -9.81]    # gravitational acceleration     [m/s²]\nL0::Float64 = 10.0                              # initial segment length            [m]\nV0::Float64 = 4                                 # initial velocity of lowest mass [m/s]\nsegments::Int64 = 2                             # number of tether segments         [-]\nPOS0 = zeros(3, segments+1)\nVEL0 = zeros(3, segments+1)\nACC0 = zeros(3, segments+1)\nSEGMENTS0 = zeros(3, segments) \nUNIT_VECTORS0 = zeros(3, segments)\nfor i in 1:segments+1\n    POS0[:, i] .= [0.0, 0, -(i-1)*L0]\n    VEL0[:, i] .= [0.0, 0, (i-1)*V0/segments]\nend\nfor i in 2:segments+1\n    ACC0[:, i] .= G_EARTH\nend\nfor i in 1:segments\n    UNIT_VECTORS0[:, i] .= [0, 0, 1.0]\n    SEGMENTS0[:, i] .= POS0[:, i+1] - POS0[:, i]\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first example of such a model is the script Tether_04.jl which is derived from the last example.","category":"page"},{"location":"examples/#Segmented-tether-with-correct-force-distribution","page":"Examples","title":"Segmented tether with correct force distribution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the script Tether_05.jl, the spring force is distributed correctly on the two masses attached to the spring as shown here:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# loop over all tether particles to apply the forces and calculate the accelerations\nfor i in 1:(segments+1)\n    global eqs2; local eqs\n    eqs = []\n    if i == segments+1\n        push!(eqs, total_force[:, i] ~ spring_force[:, i-1])\n        push!(eqs, acc[:, i]         ~ G_EARTH + total_force[:, i] / (0.5 * mass))\n    elseif i == 1\n        push!(eqs, total_force[:, i] ~ spring_force[:, i])\n        push!(eqs, acc[:, i]         ~ zeros(3))\n    else\n        push!(eqs, total_force[:, i] ~ spring_force[:, i-1] - spring_force[:, i])\n        push!(eqs, acc[:, i]         ~ G_EARTH + total_force[:, i] / mass)\n    end\n    eqs2 = vcat(eqs2, reduce(vcat, eqs))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We loop over the particles. On the first and the last particle only one spring force is acting.  On the other particles, two spring forces are acting in the opposite direction. Because the first particle is fixed we set its acceleration to zero.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Julia code: Tether_05.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Python code: Tether_05.py","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, in this example, we plot the result dynamically as 2D video. Screenshot:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Tether 2D)","category":"page"},{"location":"examples/#Multi-segment-tether-reeling-out","page":"Examples","title":"Multi-segment tether reeling out","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we assume a constant reel-out speed of V_RO=2ms. When reeling out the following values need to be dynamically calculated:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"unstretched length of a tether segment\nmass of the tether segment\nspring constant\ndamping constant","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We do this in the following way at line 76ff:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"length            ~ L0 + V_RO*t \nm_tether_particle ~ mass_per_meter * (length/segments)\nc_spring          ~ C_SPRING / (length/segments)\ndamping           ~ DAMPING  / (length/segments)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where L0 is the unstretched length of the complete tether at t=0. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Julia code: Tether_06.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The IDA solver, used for Python has a very high numerical damping. Therefore we had to multiply the damping coefficient with a factor of 0045 to achieve a more-or-less realistic result.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Python code: Tether_06.py","category":"page"},{"location":"examples/#Refactoring-the-code,-add-a-Settings-struct-and-splitting-it-into-functions","page":"Examples","title":"Refactoring the code, add a Settings struct and splitting it into functions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Julia code: Tether_06b.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you want to have fast code, that can be reused and tested using unit tests, then it is better to put your code in functions and to avoid global variables. We demonstrate that in this example.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, the settings are stored in a struct type:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"@with_kw mutable struct Settings @deftype Float64\n    g_earth::Vector{Float64} = [0.0, 0.0, -9.81] # gravitational acceleration     [m/s²]\n    l0 = 50                                      # initial tether length             [m]\n    v_ro = 2                                     # reel-out speed                  [m/s]\n    d_tether = 4                                 # tether diameter                  [mm]\n    rho_tether = 724                             # density of Dyneema            [kg/m³]\n    c_spring = 614600                            # unit spring constant              [N]\n    damping = 473                                # unit damping constant            [Ns]\n    segments::Int64 = 5                          # number of tether segments         [-]\n    α0 = π/10                                    # initial tether angle            [rad]\n    duration = 10                                # duration of the simulation        [s]\n    save::Bool = false                           # save png files in folder video\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"When defining a struct it is good to give a concrete type to each field. Here, we use Float64 as default, as defined in the first line. Apart from this type we also use the type Int64 for integer values and Bool for a boolean value.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we split the code into the functions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function calc_initial_state(se)                          # determine the initial state\nfunction model(se)                                       # create the model\nfunction simulate(se, simple_sys)                        # run the simulation\nfunction play(se, sol, pos)                              # play the simulation result, the solution\nfunction main()                                          # the main program, calling all the other functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The main() function looks like this:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function main()\n    se = Settings()\n    simple_sys, pos, vel = model(se)\n    sol = simulate(se, simple_sys)\n    play(se, sol, pos)\nend","category":"page"},{"location":"examples/#Using-a-callback-2","page":"Examples","title":"Using a callback","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"By using a callback to detect exactly when the transition from a stiff tether segment to a loose tether segment happens we can increase the accuracy of the simulation. Julia code: Tether_06c.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following lines had to be added:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"local cb\nfor i in 1:se.segments\n    cbi = [norm([pos[1, i+1] - pos[1, i], pos[2, i+1] - pos[2, i], pos[3, i+1] - pos[3, i]]) ~ abs(se.l0)/se.segments]\n    if i == 1\n        cb = cbi\n    else\n        cb = vcat(cb, cbi)\n    end\nend\n@named sys = ODESystem(eqs, t; continuous_events = cb)","category":"page"},{"location":"examples/#Segmented-tether-with-aerodynamic-drag","page":"Examples","title":"Segmented tether with aerodynamic drag","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the script Tether_07.jl, the tether drag has been added.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following lines calculate the tether drag force:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"v_app_perp[:, i]   ~ v_apparent[:, i] - (v_apparent[:, i] ⋅ unit_vector[:, i]) .* unit_vector[:, i],\nnorm_v_app[i]      ~ norm(v_app_perp[:, i]),\nhalf_drag_force[:, i] ~ 0.25 * se.rho * se.cd_tether * norm_v_app[i] * (norm1[i]*se.d_tether/1000.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following for loop the spring and drag forces are applied to the particles:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    for i in 1:(se.segments+1)\n        eqs = []\n        if i == se.segments+1\n            push!(eqs, total_force[:, i] ~ spring_force[:, i-1] + half_drag_force[:, i-1])\n            push!(eqs, acc[:, i]         ~ se.g_earth + total_force[:, i] / (0.5 * m_tether_particle))\n        elseif i == 1\n            push!(eqs, total_force[:, i] ~ spring_force[:, i] + half_drag_force[:, i])\n            push!(eqs, acc[:, i]         ~ zeros(3))\n        else\n            push!(eqs, total_force[:, i] ~ spring_force[:, i-1] - spring_force[:, i] \n                                           + half_drag_force[:, i-1] + half_drag_force[:, i])\n            push!(eqs, acc[:, i]         ~ se.g_earth + total_force[:, i] / m_tether_particle)\n        end\n        eqs2 = vcat(eqs2, reduce(vcat, eqs))\n    end","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you run the example you can see that the aerodynamic drag adds a lot of damping, the oscillations nearly die out in about 30s.","category":"page"},{"location":"examples/#Tether-with-arbitrary-endpoints","page":"Examples","title":"Tether with arbitrary endpoints","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is the same as the last one, but you can freely choose:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"both end-points\nif the end-points are fixed or if they just define the initial position","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A steady-state solver is used to solve the initial tether shape, based on the endpoints. If both endpoints are fixed you get a catenary line, deformed by the wind. This is useful for model verification.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"See: Tether_08.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Two versions of the model are implemented, with the signatures:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function model(se; p1=[0,0,0], p2=nothing, fix_p1=true, fix_p2=false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function model(se, p1, p2, fix_p1, fix_p2, POS0, VEL0, ACC0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first version calls","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"the model with fixed endpoints and zero reel-out speed\nthe steady-state solver\nand then the model with the initial positions (POS0) found by the steady-state solver, using the original values of fix_p1, fix_p2 and the original reel-out speed.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The body of this function is defined as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# straight line approximation of the tether\nPOS0, VEL0, ACC0 = calc_initial_state(se; p1, p2)\n# find steady state\nv_ro = se.v_ro      # save the reel-out speed\nse.v_ro = 0         # v_ro must be zero, otherwise finding the steady state is not possible\nsimple_sys, pos, = model(se, p1, p2, true, true, POS0, VEL0, ACC0)\ntspan = (0.0, se.duration)\nprob = ODEProblem(simple_sys, nothing, tspan)\nprob1 = SteadyStateProblem(prob)\nsol1 = solve(prob1, DynamicSS(KenCarp4(autodiff=false)))\nPOS0 = sol1[pos]\n# create the real model\nse.v_ro = v_ro\nmodel(se, p1, p2, fix_p1, fix_p2, POS0, VEL0, ACC0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Catenary)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following call was used to create this video: main(p2=[-40,0,-47], fix_p2=false), with a setting of v_ro = 0.3 m/s. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the video, you can at the beginning nicely see the catenary line which is a result of the steady state solver, and then the normal dynamic simulation, which results in a line that is pushed to the right by the wind.","category":"page"},{"location":"python/#Python-and-Julia-in-harmony","page":"Python and Julia","title":"Python and Julia in harmony","text":"","category":"section"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Python and Julia play very well together. You can see in the examples above that I am using Matplotlib for plotting, both in Python and in Julia. Julia has a built-in package manager. You can use it to install and remove Julia packages, but also to install or remove Python packages. That works like this:","category":"page"},{"location":"python/#Using-Python-packages-from-Julia","page":"Python and Julia","title":"Using Python packages from Julia","text":"","category":"section"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"There are three options:","category":"page"},{"location":"python/#Option-one:","page":"Python and Julia","title":"Option one:","text":"","category":"section"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Use wrapper libraries that exist for a few, very popular Python packages, e.g. PyPlot.jl for Matplotlib or SymPy.jl for SymPy. You can install them like any other Julia package, e.g.","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"]     # enter package manager mode\nadd SymPy\n<DEL> # leave the package manager","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"and on the Julia prompt:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"using SymPy","category":"page"},{"location":"python/#Option-two:","page":"Python and Julia","title":"Option two:","text":"","category":"section"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Use PyCall to use Python packages for Julia. This works for all Python packages, but  is a little bit less comfortable than option one. Example:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"using PyCall\nnp = pyimport(\"numpy\")","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Now you can use NumPy from Julia:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"julia> np.zeros(3)\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"If the package is not yet installed, you can use the notation:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"as = pyimport_conda(\"assimulo\", \"assimulo\")","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"If the command using PyCall should fail, you can execute:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"cd bin\n./build_pycall","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"to re-build it.","category":"page"},{"location":"python/#Option-three:","page":"Python and Julia","title":"Option three:","text":"","category":"section"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Using the package PythonCall. You cannot use it together with PyCall, it is the newer successor of PyCall, and it is symmetric, you can use it to call Julia from Python or Python from Julia.","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"We need to create a new project to try it out:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"cd repos # or any other folder that you use for your projects\nmkdir PythonDemo\ncd PythonDemo\njulia --project=\".\" # this creates a new, empty project","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Then enter at the Julia prompt: Example of using Python from Julia:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"re = pyimport(\"re\")   # import the re module\nwords = re.findall(\"[a-zA-Z]+\", \"PythonCall.jl is very useful!\")","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Output:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Python: ['PythonCall', 'jl', 'is', 'very', 'useful']","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Type:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"sentence = Py(\" \").join(words)","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Output:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Python: 'PythonCall jl is very useful'","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"And finally, convert this Python object to a Julia string:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"pyconvert(String, sentence)  # convert the Python string to a Julia string","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"For adding Python packages that you want to use with PythonCall use CondaPkg as explained in the next section.","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Sometimes needed: Install CondaPkg","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"] # by pressing the closing square bracket you enter the package manager mode of Julia\nadd CondaPkg # add the Python package manger\n","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Now press the \\<DEL\\> key to leave the package manager. In the Julia REPL, type:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"using CondaPkg\n]                 # enter the package manager mode\nhelp              # will show you all available commands; try for example\nconda add ipython # this will add ipython","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Press \\<DEL\\> to leave the package manager mode. In the Julia REPL, type:","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"CondaPkg.withenv() do\n    run(`ipython`)\nend","category":"page"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"You should now get an interactive Python prompt and can program in Python.","category":"page"},{"location":"python/#Further-reading","page":"Python and Julia","title":"Further reading","text":"","category":"section"},{"location":"python/","page":"Python and Julia","title":"Python and Julia","text":"Noteworthy differences Julia/Python Good to know.\nPythonCall.jl New library to call Python from Julia or Julia from Python.\nPyCall Old library to call Python from Julia.","category":"page"},{"location":"#Tethers.jl","page":"Readme","title":"Tethers.jl","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"(Image: Dev) (Image: Build Status)","category":"page"},{"location":"#Introduction","page":"Readme","title":"Introduction","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"A few examples where tether models can be useful:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"cranes\nundersea cables\nmooring lines of floating wind turbines\nairborne wind energy systems\nlaunching of sailplanes","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"(Image: Tether)","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Modeling of tethers and cables is difficult for several reasons. One of them is the high stiffness of the equation systems that need to be solved. I tried to implement these models with Simulink and Modelica and failed. It is possible to implement these models with Julia or Python. How to do this is explained in this tutorial. Tethers that are reeled in and out from a winch are even more challenging to model than constant-length tethers.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"A series of examples, from a simple falling mass towards a tether model, consisting of point masses connected by spring damper elements with the support of reel-out and reel-in and aerodynamic drag attached is presented.","category":"page"},{"location":"#Status","page":"Readme","title":"Status","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"the Julia examples are of good quality and well-documented and tested\nthe Python examples need some more work","category":"page"},{"location":"#Installation","page":"Readme","title":"Installation","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"Make sure you are running a bash terminal (shell) and you have at least 16GB RAM (MAC, Linux and Windows supported).      On Windows, you can use git for windows which provides git AND a bash shell, but for using Julia from a bash terminal you must also install either  Installation and usage of VSCode or Windows Terminal. Windows Terminal is the simple and clean solution, VSCode the comfortable, fancy solution.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Check out from git:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"cd repos # any folder of your choice, but without spaces in the folder name\ngit clone https://github.com/ufechner7/Tethers.jl","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Build the system image:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"cd repos/Tethers.jl\ncd bin\n./create_sys_image","category":"page"},{"location":"#Basic-example","page":"Readme","title":"Basic example","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"Use the provided script to start Julia from the Tethers.jl folder:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"cd repos/Tethers.jl\n./bin/run_julia","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"From the Julia prompt, run the simulation:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"include(\"src/Tether_01.jl\")","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"You should see a plot similar to:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"(Image: Falling mass)","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"This example shows a mass that is thrown upwards, slows down and then falls.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"HINT   You get a menu from which you can run any of the examples by typing","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"menu()","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"at the Julia prompt.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Julia code: Tether_01.jl","category":"page"},{"location":"#Python-version-as-comparison","page":"Readme","title":"Python version as comparison","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"From the Julia prompt execute:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"include(\"src/RunTether_01.jl\")","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"This will install Python, Matplotlib and Assimulo and execute the script Tether_01.py.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Python code: Tether_01.py","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"If you compare the Python and the Julia scripts you can see that:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"the Julia script is shorter and easier to read\nJulia is about 16 times faster when running the simulation  ","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"For a stiff, segmented tether (example 6 and 7) the Julia solvers are more than 2000 times faster than Python.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Have a look at the Examples that teach you how to construct a full tether model step by step.","category":"page"},{"location":"#Overall-comparison","page":"Readme","title":"Overall comparison","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"Execution time for a simulation of 10s duration with logging the state every 20ms. Relative and absolute tolerance: 10^-6. CPU: Ryzen 9 7950X.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Test-case Lines of code (LOC) Julia LOC Python Time Julia [ms] Time Python [ms]\nFalling mass (1) 35 56 0.17 2.6\nNon-linear Spring damper (3) 49 83 0.64 20\nditto with callbacks (3b, 3c) 57 103 0.8 31\nswinging tether, 5 segments (5) 109 150 2.9 47\nDyneema tether, reeling out (6) 125 160 4.3 9300\nditto with callbacks       (6c) 156  4.3 \nDyneema, reeling out with drag (7) 175  3.3 ","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Tradeoff Julia vs Python: In Julia, the code is compiled before it is executed, which can cause about one to 10 seconds delay when running a simulation the first time, but speeds up the execution a lot afterward. In addition, Julia can run fully multithreaded, Python cannot make use of multiple CPU cores with multithreading because of the global interpreter lock. ","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Furthermore, the IDA solver is hardly capable of handling a simulation with the very stiff Dyneema tether. The Julia solvers achieve more than 2000 times the performance.","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"See also: Why Julia? and read the documentation or go straight to the examples.","category":"page"},{"location":"vscode/#Installation-and-usage-of-VSCode","page":"VSCode IDE","title":"Installation and usage of VSCode","text":"","category":"section"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"It is useful to install the integrated development environment VSCode, even though it is not required. You can also use any editor of your choice.","category":"page"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"VSCode provides syntax highlighting, but also the feature \"goto definition\" which can help to understand and explore the code. (Image: VSCode)","category":"page"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"You can download and install VSCode for all operating systems here.","category":"page"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"Julia development with VSCode is well documented here.","category":"page"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"I suggest to install the following Extensions:","category":"page"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"Julia\nProject Manager \nYAML\nEven Better TOML","category":"page"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"VSCode has good, integrated GIT support by default, no extension is needed for that.","category":"page"},{"location":"vscode/","page":"VSCode IDE","title":"VSCode IDE","text":"I would NOT use all the advanced features of julia-vscode, I prefer to just use the vscode terminal and launch Julia from the terminal. This makes it easy to launch Julia with any command line options and also to start and restart Julia quickly.","category":"page"}]
}

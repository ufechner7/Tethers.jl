<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Tethers.jl</title><meta name="title" content="Examples · Tethers.jl"/><meta property="og:title" content="Examples · Tethers.jl"/><meta property="twitter:title" content="Examples · Tethers.jl"/><meta name="description" content="Documentation for Tethers.jl."/><meta property="og:description" content="Documentation for Tethers.jl."/><meta property="twitter:description" content="Documentation for Tethers.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Tethers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Readme</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Mass,-thrown-upwards,-then-falling"><span>Mass, thrown upwards, then falling</span></a></li><li><a class="tocitem" href="#Mass,-attached-to-a-spring-damper"><span>Mass, attached to a spring-damper</span></a></li><li><a class="tocitem" href="#Mass,-with-non-linear-spring-damper"><span>Mass, with non-linear spring damper</span></a></li><li><a class="tocitem" href="#Benchmarking-non-linear-simulation"><span>Benchmarking non-linear simulation</span></a></li><li><a class="tocitem" href="#Multi-segment-tether"><span>Multi-segment tether</span></a></li><li><a class="tocitem" href="#Segmented-tether-with-correct-force-distribution"><span>Segmented tether with correct force distribution</span></a></li><li><a class="tocitem" href="#Multi-segment-tether-reeling-out"><span>Multi-segment tether reeling out</span></a></li><li><a class="tocitem" href="#Segmented-tether-with-aerodynamic-drag"><span>Segmented tether with aerodynamic drag</span></a></li></ul></li><li><a class="tocitem" href="../vscode/">VSCode IDE</a></li><li><a class="tocitem" href="../python/">Python and Julia</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/Tethers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/Tethers.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>A sequence of examples, from a simple mass attached to a spring-damper element to a full segmented tether model with real-out and aerodynamic drag attached.</p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Description</th><th style="text-align: left">Learning objective</th></tr><tr><td style="text-align: left">Tether_01</td><td style="text-align: left"><a href="#Mass,-thrown-upwards,-then-falling">Mass, thrown upwards, then falling</a></td><td style="text-align: left">Learn how to define a model, simulate it and plot the results</td></tr><tr><td style="text-align: left">Tether_02</td><td style="text-align: left"><a href="#Mass,-attached-to-a-spring-damper">Mass, attached to a spring-damper</a></td><td style="text-align: left">Learn how to model a spring in 3D</td></tr><tr><td style="text-align: left">Tether_03</td><td style="text-align: left"><a href="#Mass,-with-non-linear-spring-damper">Mass, with non-linear spring-damper</a></td><td style="text-align: left">Learn how to model  DAE systems with discontinuities</td></tr><tr><td style="text-align: left">Tether_04</td><td style="text-align: left"><a href="#Multi-segment-tether">Multi-segment tether</a></td><td style="text-align: left">Learn how to use arrays of equations</td></tr><tr><td style="text-align: left">Tether_05</td><td style="text-align: left"><a href="#Segmented-tether-with-correct-force-distribution">Segmented tether with correct force distribution</a></td><td style="text-align: left">Learn how to distribute the spring force over two masses</td></tr><tr><td style="text-align: left">Tether_06</td><td style="text-align: left"><a href="#Multi-segment-tether-reeling-out">Multi-segment tether reeling out</a></td><td style="text-align: left">Learn to model a tether with changing unstretched length</td></tr><tr><td style="text-align: left">Tether_07</td><td style="text-align: left"><a href="#Segmented-tether-with-aerodynamic-drag">Segmented tether with aerodynamic drag</a></td><td style="text-align: left">Learn how to model tether drag</td></tr></table><p><strong>Nomenclature:</strong></p><ul><li>ODE: Ordinary differential equations</li><li>DAE: Differential algebraic equations</li></ul><h2 id="Mass,-thrown-upwards,-then-falling"><a class="docs-heading-anchor" href="#Mass,-thrown-upwards,-then-falling">Mass, thrown upwards, then falling</a><a id="Mass,-thrown-upwards,-then-falling-1"></a><a class="docs-heading-anchor-permalink" href="#Mass,-thrown-upwards,-then-falling" title="Permalink"></a></h2><p>Use the provided script to start Julia from the <code>Tethers.jl</code> folder:</p><pre><code class="language-bash hljs">cd repos/Tethers.jl
./bin/run_julia</code></pre><p>From the Julia prompt, run the simulation:</p><pre><code class="language-julia hljs">include(&quot;src/Tether_01.jl&quot;)</code></pre><p>You should see a plot similar to:</p><p><img src="../docs/images/FallingMass.png" alt="Falling mass"/></p><p>This example shows a mass that is thrown upwards, slows down and then falls.</p><p><strong>Julia code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_01.jl">Tether_01.jl</a></p><p>These differential equations define the model:</p><pre><code class="language-Julia hljs">D = Differential(t)

eqs = vcat(D.(pos) ~ vel,
           D.(vel) ~ acc,
           acc    .~ G_EARTH)</code></pre><p>The term <code>D.(pos)</code> means &quot;Apply the differential D(t) to all elements of the vector <code>pos</code>&quot;. The second term defines that the differential of the velocity vector must be equal to the  acceleration. For equality in symbolic equations the character <code>~</code> has to be used, because the character <code>=</code> has the meaning &quot;assign a value to a variable&quot; which is not what we are doing here. The third equation means that all elements of the acceleration vector must be equal to the elements of the gravity vector. We end up with an array of <code>3x3</code>` equations.</p><p>The next lines are:</p><pre><code class="language-julia hljs">@named sys = ODESystem(eqs, t)
simple_sys = structural_simplify(sys)</code></pre><p>This means we create a named ordinary equation system, depending on <code>t</code>. Then we simplify the system symbolically (order reduction). If you type <code>sys</code> in the Julia REPL (command line) you can see that the original system had 9 equations, the second line above created a system with only six equations. This step helps to speed up the simulation and often also removes algebraic loops which makes the ODE a lot simpler to solve numerically later on.</p><p>Now the parameters of the integrator are defined:</p><pre><code class="language-julia hljs">duration = 10.0
dt = 0.02
tol = 1e-6
ts    = 0:dt:duration</code></pre><p>The time step <span>$dt$</span> is the interval in which the solution shall be stored, NOT the time step of the integrator. The integrator uses a variable time step which can be much smaller or much larger as determined by the required tolerance, in this example set to <span>$tol=10^{-6}$</span>. The variable <span>$ts$</span> is a range object defining the sampling times for the result.</p><p>In the next lines, we define the ODE problem and finally, we solve it using the Rodas5 solver with the given parameters. The second parameter defines the initial conditions. We use <code>nothing</code> here because we defined the initial conditions already in the <a href="https://github.com/ufechner7/Tethers.jl/blob/87635d9df32f3ded49d0a394b613b412c2c83d55/src/Tether_01.jl#L7C1-L9C44">model</a>.</p><pre><code class="language-julia hljs">prob = ODEProblem(simple_sys, nothing, (0.0, duration))
@time sol = solve(prob, Rodas5(), dt=dt, abstol=tol, reltol=tol, saveat=ts)</code></pre><p>The macro <code>@time</code> measures the compilation and execution time of calling the function <code>solve()</code>. The function is compiled only when called the first time. </p><h3 id="Python-version-as-comparison"><a class="docs-heading-anchor" href="#Python-version-as-comparison">Python version as comparison</a><a id="Python-version-as-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Python-version-as-comparison" title="Permalink"></a></h3><p>From the Julia prompt execute:</p><pre><code class="nohighlight hljs">include(&quot;src/RunTether.jl&quot;)</code></pre><p>This will install Python, Matplotlib and Assimulo and execute the script <code>Tether_01.py</code>.</p><p><strong>Python code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_01.py">Tether_01.py</a></p><p>If you compare the Python and the Julia scripts you can see that:</p><ul><li>the Julia script is shorter and easier to read</li><li>Julia is about 16 times faster when running the simulation</li></ul><h2 id="Mass,-attached-to-a-spring-damper"><a class="docs-heading-anchor" href="#Mass,-attached-to-a-spring-damper">Mass, attached to a spring-damper</a><a id="Mass,-attached-to-a-spring-damper-1"></a><a class="docs-heading-anchor-permalink" href="#Mass,-attached-to-a-spring-damper" title="Permalink"></a></h2><p>From the Julia prompt, run the simulation:</p><pre><code class="language-julia hljs">include(&quot;src/Tether_02.jl&quot;)</code></pre><p><img src="../docs/images/SpringDamper.png" alt="Spring damper"/></p><p>Mass, attached to a spring-damper element. One end of the spring is attached at the origin, the second end is attached to the mass. Mass initially below the origin, spring un-stretched. Z-axis pointing upwards.</p><p><strong>Julia code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_02.jl">Tether_02.jl</a></p><h2 id="Mass,-with-non-linear-spring-damper"><a class="docs-heading-anchor" href="#Mass,-with-non-linear-spring-damper">Mass, with non-linear spring damper</a><a id="Mass,-with-non-linear-spring-damper-1"></a><a class="docs-heading-anchor-permalink" href="#Mass,-with-non-linear-spring-damper" title="Permalink"></a></h2><pre><code class="language-julia hljs">include(&quot;src/Tether_03.jl&quot;)</code></pre><p><img src="../docs/images/Nonlinear.png" alt="Non-linear Spring damper"/></p><p>Mass, attached to a non-linear spring-damper element. One end of the spring is attached at the origin, and the second end is attached to the mass. Mass initially below the origin, spring un-stretched. Z-axis pointing upwards. </p><p>Initial velocity <span>$4 m/s$</span> upwards. The compression stiffness is zero. The grey line shows that the stiffness is zero at the beginning, and has the nominal value at the end. <strong>Example:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_03.jl">Tether_03.jl</a>.</p><p>Thanks to the package <a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit.jl</a> the system description is very compact and readable:</p><pre><code class="language-Julia hljs">eqs = vcat(D.(pos)      ~ vel,
           D.(vel)      ~ acc,
           norm1        ~ norm(pos),
           unit_vector  ~ -pos/norm1,         # direction from point mass to origin
           spring_vel   ~ -unit_vector ⋅ vel,
           c_spring     ~ c_spring0 * (norm1 &gt; abs(l0)),
           spring_force ~ (c_spring * (norm1 - abs(l0)) + damping * spring_vel) * unit_vector,
           acc          ~ G_EARTH + spring_force/mass)</code></pre><p>The same in Python: <strong>Python code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_03.py">Tether_03.py</a>. </p><h3 id="Using-a-callback"><a class="docs-heading-anchor" href="#Using-a-callback">Using a callback</a><a id="Using-a-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-callback" title="Permalink"></a></h3><p>By using a callback to detect exactly when the transition from a stiff tether segment to a loose tether segment happens we can increase the accuracy of the simulation. <strong>Julia code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_03b.jl">Tether_03b.jl</a>.</p><p>We only have to add the following lines of code:</p><pre><code class="language-julia hljs">function condition(u, t, integrator) # Event when condition(u,t,integrator) == 0
    norm(u[1:3]) - abs(L0)
end
function affect!(integrator)
    println(integrator.t)            # Not needed, just to show that the callback works
end
cb = ContinuousCallback(condition, affect!)</code></pre><p>and add the parameter <code>callback = cb</code> to the line that calls the solver:</p><pre><code class="language-julia hljs">sol = solve(prob, Rodas5(), dt=dt, abstol=tol, reltol=tol, saveat=ts, callback = cb)</code></pre><h3 id="Using-a-callback-with-Python"><a class="docs-heading-anchor" href="#Using-a-callback-with-Python">Using a callback with Python</a><a id="Using-a-callback-with-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-callback-with-Python" title="Permalink"></a></h3><p>In Python you would have to add the following attribute:</p><pre><code class="language-Python hljs">    sw0 = [vel_1[2] &gt; 0] # array of booleans; true means the tether segment is loose (l &lt; l_0)</code></pre><p>and the following methods:</p><pre><code class="language-Python hljs">    def state_events(self, t, y, yd, sw):
        &quot;&quot;&quot;
        This is our function that keeps track of our events. When the sign
        of any of the events has changed, we have an event.
        &quot;&quot;&quot;
        # calculate the norm of the vector from mass1 to mass0 minus the initial segment length
        event_0 = np.linalg.norm(y[3:6]) - L_0
        return np.array([event_0])
    
    def handle_event(self, solver, event_info):
        &quot;&quot;&quot;
        Event handling. This functions is called when Assimulo finds an event as
        specified by the event functions.
        &quot;&quot;&quot;
        state_info = event_info[0] # We are only interested in state events
        if state_info[0] != 0:     # Check if the first event function has been triggered
            if solver.sw[0]:       # If the switch is True the pendulum bounces
                print(solver.t)</code></pre><p><strong>Example:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_03b.py">Tether_03b.py</a>.   As you can see, logging of calculated variables is not possible with Assimulo (easy with ModelingToolkit in Julia). You need to re-calculate them after the simulation.</p><h2 id="Benchmarking-non-linear-simulation"><a class="docs-heading-anchor" href="#Benchmarking-non-linear-simulation">Benchmarking non-linear simulation</a><a id="Benchmarking-non-linear-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking-non-linear-simulation" title="Permalink"></a></h2><p>Using a callback slows the simulation down, but not much. Try it out:</p><pre><code class="language-julia hljs">include(&quot;src/Tether_03c.jl&quot;)</code></pre><p>Output on a fast PC:</p><pre><code class="nohighlight hljs">Solving the system without callback...
  0.000606 seconds (8.06 k allocations: 257.672 KiB)
Press any key...

Solving the system with callback...
  0.000741 seconds (9.93 k allocations: 365.812 KiB)
If you zoom in to the points in time where pos_z crosses -10m
you should see a difference...</code></pre><p>In this example, the gain of accuracy is very small, but that can be different in other simulations. For benchmarking we call solve twice: The first call ensures that the code is compiled, and the second call measures the execution time of the code.</p><p><strong>Python</strong> The script, which executes the Python code with callbacks:</p><pre><code class="nohighlight hljs">include(&quot;src/RunTether_03b.jl&quot;)</code></pre><p>reports 31 ms for solving the problem (without printing). Without callbacks:</p><pre><code class="nohighlight hljs">include(&quot;src/RunTether_03.jl&quot;)</code></pre><p>still, 20 ms are needed.</p><h2 id="Multi-segment-tether"><a class="docs-heading-anchor" href="#Multi-segment-tether">Multi-segment tether</a><a id="Multi-segment-tether-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-segment-tether" title="Permalink"></a></h2><p>Using 2D arrays of variables allows to simulate a multi-segment tether:</p><pre><code class="language-julia hljs">@variables pos(t)[1:3, 1:segments+1]  = POS0
@variables vel(t)[1:3, 1:segments+1]  = VEL0
@variables acc(t)[1:3, 1:segments+1]  = ACC0</code></pre><p>In this case, it is important to calculate the initial conditions of each particle such that they are physically feasible:</p><pre><code class="language-julia hljs">G_EARTH::Vector{Float64} = [0.0, 0.0, -9.81]    # gravitational acceleration     [m/s²]
L0::Float64 = 10.0                              # initial segment length            [m]
V0::Float64 = 4                                 # initial velocity of lowest mass [m/s]
segments::Int64 = 2                             # number of tether segments         [-]
POS0 = zeros(3, segments+1)
VEL0 = zeros(3, segments+1)
ACC0 = zeros(3, segments+1)
SEGMENTS0 = zeros(3, segments) 
UNIT_VECTORS0 = zeros(3, segments)
for i in 1:segments+1
    POS0[:, i] .= [0.0, 0, -(i-1)*L0]
    VEL0[:, i] .= [0.0, 0, (i-1)*V0/segments]
end
for i in 2:segments+1
    ACC0[:, i] .= G_EARTH
end
for i in 1:segments
    UNIT_VECTORS0[:, i] .= [0, 0, 1.0]
    SEGMENTS0[:, i] .= POS0[:, i+1] - POS0[:, i]
end</code></pre><p>The first example of such a model is the script <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_04.jl">Tether_04.jl</a> which is derived from the last example.</p><h2 id="Segmented-tether-with-correct-force-distribution"><a class="docs-heading-anchor" href="#Segmented-tether-with-correct-force-distribution">Segmented tether with correct force distribution</a><a id="Segmented-tether-with-correct-force-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Segmented-tether-with-correct-force-distribution" title="Permalink"></a></h2><p>In the script <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_05.jl#L61">Tether_05.jl</a>, the spring force is distributed correctly on the two masses attached to the spring as shown here:</p><pre><code class="language-julia hljs"># loop over all tether particles to apply the forces and calculate the accelerations
for i in 1:(segments+1)
    global eqs2; local eqs
    eqs = []
    if i == segments+1
        push!(eqs, total_force[:, i] ~ spring_force[:, i-1])
        push!(eqs, acc[:, i]         ~ G_EARTH + total_force[:, i] / (0.5 * mass))
    elseif i == 1
        push!(eqs, total_force[:, i] ~ spring_force[:, i])
        push!(eqs, acc[:, i]         ~ zeros(3))
    else
        push!(eqs, total_force[:, i] ~ spring_force[:, i-1] - spring_force[:, i])
        push!(eqs, acc[:, i]         ~ G_EARTH + total_force[:, i] / mass)
    end
    eqs2 = vcat(eqs2, reduce(vcat, eqs))
end</code></pre><p>We loop over the particles. The first and the last particle only one spring force is acting.  On the other particles two spring forces are acting in the opposite direction. Because the first particle is fixed we set its acceleration to zero.</p><p><strong>Julia code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_05.jl">Tether_05.jl</a></p><p><strong>Python code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_05.py">Tether_05.py</a></p><p>Finally, in this example, we plot the result dynamically as 2D video. Screenshot:</p><p><img src="../docs/images/Tether2d.png" alt="Tether 2D"/></p><h2 id="Multi-segment-tether-reeling-out"><a class="docs-heading-anchor" href="#Multi-segment-tether-reeling-out">Multi-segment tether reeling out</a><a id="Multi-segment-tether-reeling-out-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-segment-tether-reeling-out" title="Permalink"></a></h2><p>In this example, we assume a constant reel-out speed of <span>$V_{RO}=2m/s$</span>. When reeling out the following values need to be dynamically calculated:</p><ul><li>unstretched length of a tether segment</li><li>mass of the tether segment</li><li>spring constant</li><li>damping constant</li></ul><p>We do this in the following way at <a href="https://github.com/ufechner7/Tethers.jl/blob/87635d9df32f3ded49d0a394b613b412c2c83d55/src/Tether_06.jl#L76C1-L79C59">line 76ff</a>:</p><pre><code class="language-julia hljs">length            ~ L0 + V_RO*t 
m_tether_particle ~ mass_per_meter * (length/segments)
c_spring          ~ C_SPRING / (length/segments)
damping           ~ DAMPING  / (length/segments)</code></pre><p>where <code>L0</code> is the unstretched length of the complete tether at <span>$t=0$</span>. </p><p><strong>Julia code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_06.jl">Tether_06.jl</a></p><p>The IDA solver, used for Python has a very high numerical damping. Therefore we had to multiply the damping coefficient with a factor of <span>$0.045$</span> to achieve a more-or-less realistic result.</p><p><strong>Python code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_06.py">Tether_06.py</a></p><h3 id="Refactoring-the-code,-add-a-Settings-struct-and-splitting-it-into-functions"><a class="docs-heading-anchor" href="#Refactoring-the-code,-add-a-Settings-struct-and-splitting-it-into-functions">Refactoring the code, add a Settings struct and splitting it into functions</a><a id="Refactoring-the-code,-add-a-Settings-struct-and-splitting-it-into-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Refactoring-the-code,-add-a-Settings-struct-and-splitting-it-into-functions" title="Permalink"></a></h3><p><strong>Julia code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_06b.jl">Tether_06b.jl</a>.</p><p>If you want to have fast code, that can be reused and tested using unit tests, then it is better to put your code in functions and to avoid global variables. We demonstrate that in this example.</p><p>First, the settings are stored in a <code>struct</code> type:</p><pre><code class="language-julia hljs">@with_kw mutable struct Settings @deftype Float64
    g_earth::Vector{Float64} = [0.0, 0.0, -9.81] # gravitational acceleration     [m/s²]
    l0 = 50                                      # initial tether length             [m]
    v_ro = 2                                     # reel-out speed                  [m/s]
    d_tether = 4                                 # tether diameter                  [mm]
    rho_tether = 724                             # density of Dyneema            [kg/m³]
    c_spring = 614600                            # unit spring constant              [N]
    damping = 473                                # unit damping constant            [Ns]
    segments::Int64 = 5                          # number of tether segments         [-]
    α0 = π/10                                    # initial tether angle            [rad]
    duration = 10                                # duration of the simulation        [s]
    save::Bool = false                           # save png files in folder video
end</code></pre><p>When defining a <code>struct</code> it is good to give a concrete type to each field. Here, we use Float64 as default, as defined in the first line. Apart from this type we also use the type <code>Int64</code> for integer values and <code>Bool</code> for a boolean value.</p><p>Then we split the code into the functions:</p><pre><code class="language-julia hljs">function calc_initial_state(se)                          # determine the initial state
function model(se)                                       # create the model
function simulate(se, simple_sys)                        # run the simulation
function plot2d(se, sol, pos, reltime, line, sc, txt, j) # plot the state for one point in time
function play(se, sol, pos)                              # play the simulation result, the solution
function main()                                          # the main program, calling all the other functions</code></pre><p>The <code>main()</code> function looks like this:</p><pre><code class="language-julia hljs">function main()
    se = Settings()
    simple_sys, pos, vel = model(se)
    sol = simulate(se, simple_sys)
    play(se, sol, pos)
end</code></pre><h3 id="Using-a-callback-2"><a class="docs-heading-anchor" href="#Using-a-callback-2">Using a callback</a><a class="docs-heading-anchor-permalink" href="#Using-a-callback-2" title="Permalink"></a></h3><p>By using a callback to detect exactly when the transition from a stiff tether segment to a loose tether segment happens we can increase the accuracy of the simulation. <strong>Julia code:</strong> <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_06c.jl">Tether_06c.jl</a>.</p><p>The following lines had to be added:</p><pre><code class="language-julia hljs">local cb
for i in 1:se.segments
    cbi = [norm([pos[1, i+1] - pos[1, i], pos[2, i+1] - pos[2, i], pos[3, i+1] - pos[3, i]]) ~ abs(se.l0)/se.segments]
    if i == 1
        cb = cbi
    else
        cb = vcat(cb, cbi)
    end
end
@named sys = ODESystem(eqs, t; continuous_events = cb)</code></pre><h2 id="Segmented-tether-with-aerodynamic-drag"><a class="docs-heading-anchor" href="#Segmented-tether-with-aerodynamic-drag">Segmented tether with aerodynamic drag</a><a id="Segmented-tether-with-aerodynamic-drag-1"></a><a class="docs-heading-anchor-permalink" href="#Segmented-tether-with-aerodynamic-drag" title="Permalink"></a></h2><p>In the script <a href="https://github.com/ufechner7/Tethers.jl/blob/main/src/Tether_07.jl">Tether_07.jl</a>, the tether drag has been added.</p><p>The following lines calculate the tether drag force:</p><pre><code class="language-julia hljs">v_app_perp[:, i]   ~ v_apparent[:, i] - (v_apparent[:, i] ⋅ unit_vector[:, i]) .* unit_vector[:, i],
norm_v_app[i]      ~ norm(v_app_perp[:, i]),
half_drag_force[:, i] ~ 0.25 * se.rho * se.cd_tether * norm_v_app[i] * (norm1[i]*se.d_tether/1000.0)</code></pre><p>In the following for loop the spring and drag forces are applied to the particles:</p><pre><code class="language-julia hljs">    for i in 1:(se.segments+1)
        eqs = []
        if i == se.segments+1
            push!(eqs, total_force[:, i] ~ spring_force[:, i-1] + half_drag_force[:, i-1])
            push!(eqs, acc[:, i]         ~ se.g_earth + total_force[:, i] / (0.5 * m_tether_particle))
        elseif i == 1
            push!(eqs, total_force[:, i] ~ spring_force[:, i] + half_drag_force[:, i])
            push!(eqs, acc[:, i]         ~ zeros(3))
        else
            push!(eqs, total_force[:, i] ~ spring_force[:, i-1] - spring_force[:, i] 
                                           + half_drag_force[:, i-1] + half_drag_force[:, i])
            push!(eqs, acc[:, i]         ~ se.g_earth + total_force[:, i] / m_tether_particle)
        end
        eqs2 = vcat(eqs2, reduce(vcat, eqs))
    end</code></pre><p>If you run the example you can see that the aerodynamic drag adds a lot of damping, the oscillations nearly die out in about 30s.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Theory</a><a class="docs-footer-nextpage" href="../vscode/">VSCode IDE »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Sunday 18 August 2024 15:07">Sunday 18 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
